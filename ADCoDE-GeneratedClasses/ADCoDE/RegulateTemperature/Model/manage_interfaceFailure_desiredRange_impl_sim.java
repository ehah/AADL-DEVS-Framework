/**
* generated by ADCoDE @ 2019-12-04 16:13:59
* This class represents DEVS atomic model for thread manage_interfaceFailure_desiredRange with manage_interfaceFailure_desiredRange.impl
**/
package RegulateTemperature;

import java.lang.*;
import GenCol.*;
import model.modeling.*;
import model.simulation.*;
import view.modeling.ViewableAtomic;
import view.simView.*;
import component.structuredEntities.*;
import component.Iso_Types.*;
	
public class manage_interfaceFailure_desiredRange_impl_sim extends ViewableAtomic {
			
	// entities
	protected doubleEnt ldtX;
	protected doubleEnt udtX;
	protected booleanEnt rifX;
	
	// variables
	private IntRange dt = new IntRange(68, 105, 90);
	private lower_desired_temperature ldt = new lower_desired_temperature(98, "Valid");
	private upper_desired_temperature udt = new upper_desired_temperature(99, "Valid");
	private booleanEnt rif = new booleanEnt(true);
		private doubleEnt pd = new doubleEnt(100.0);
	private stringEnt unspecified_value =  new stringEnt("unpecified_value");
	
	//for port datatypes
	private IntRange lower_desired_temp = new IntRange(96, 101, 98);
	private IntRange upper_desired_temp = new IntRange(97, 102, 0);//variable generated for future reference.
	
	public manage_interfaceFailure_desiredRange_impl_sim() {
		this("manage_interfaceFailure_desiredRange.impl");
	}
			
	public manage_interfaceFailure_desiredRange_impl_sim(String name) {
		super(name);
			 
		//input and output ports from and for other atomic/coupled models
		// it is recommended to use short names
				
		addInport("lower_desired_temperature"); 
		addInport("upper_desired_temperature"); 
		addOutport("regulator_interface_failure"); 
		addOutport("lower_desired_temp"); 
		addOutport("upper_desired_temp"); 
		addOutport("unspecified_temp"); 

		//test input for standalone testing
		addTestInput("lower_desired_temperature", new lower_desired_temperature(97, "Valid"));
		addTestInput("lower_desired_temperature", new lower_desired_temperature(100, "Invalid"));
		addTestInput("upper_desired_temperature", new upper_desired_temperature(101, "Invalid"));
		addTestInput("upper_desired_temperature", new upper_desired_temperature(98, "Valid"));
		addTestInput("lower_desired_temp", new intEnt(98));
		addTestInput("regulator_interface_failure", new booleanEnt(true));
	}	
			
	public void initialize() {
		//Can be updated by the modeler 
		phase = "Start";
		sigma = 0.0;

	  	super.initialize();
	}
			
	public void deltint() {
		if (phaseIs("Start")) {
		  holdIn("Chk_Status", pd.getv());
		}
		if (phaseIs("Set_Vars")) {
		  holdIn("Chk_Status", pd.getv());
		}
	}
			
	public void deltext(double e, message x) {
		Continue(e);
		
		if (phaseIs("Chk_Status")) {
		 	for(int i=0; i<x.getLength(); i++) {
				if(messageOnPort(x, "lower_desired_temperature", i)) {
			 	ldt = (lower_desired_temperature) x.getValOnPort("lower_desired_temperature", i);
			 	if(ldt.get_status() == "Invalid" || udt.get_status() == "Invalid") 
			 			  	   		{rif.setv(true);}
			 				    else {rif.setv(false);}
			 	holdIn("Set_Vars", 0.0);
				}
			}
		}
		if (phaseIs("Chk_Status")) {
		 	for(int i=0; i<x.getLength(); i++) {
				if(messageOnPort(x, "upper_desired_temperature", i)) {
			 	udt = (upper_desired_temperature) x.getValOnPort("upper_desired_temperature", i);
			 	if(udt.get_status() == "Invalid" || ldt.get_status() == "Invalid") 
			 			  	   		{rif.setv(true);}
			 				    else { rif.setv(false); }
			 	holdIn("Set_Vars", 0.0);
				}
			}
		}
	}
			
	public message out() {
		message m = new message();
		
		if (phaseIs("Set_Vars"))
		m.add(makeContent("regulator_interface_failure", rif));
		if (phaseIs("Set_Vars"))
		 {
		 if(  rif.getv()!= true)
		 m.add(makeContent("lower_desired_temp",  ldt.get_t()));
		 }
		if (phaseIs("Set_Vars"))
		 {
		 if(  rif.getv()!= true)
		 m.add(makeContent("upper_desired_temp",  udt.get_t()));
		 }
		if (phaseIs("Set_Vars"))
		 {
		 if(  rif.getv()== true)
		 m.add(makeContent("unspecified_temp",  unspecified_value));
		 }
		
		return m;
	}
}
